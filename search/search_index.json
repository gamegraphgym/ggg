{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Game Graph Gym","text":"<p>Welcome to the Game Graph Gym documentation! This framework provides a comprehensive C++20 library for implementing and benchmarking solvers for games on graphs.</p>"},{"location":"#overview","title":"Overview","text":"<p>Game Graph Gym (GGG) is a modern C++20 framework designed for implementing and benchmarking game-theoretic solvers. The architecture consists of:</p> <ul> <li>Core Library (<code>libggg</code>): Built on Boost Graph Library, provides graph types (Parity, Mean-Payoff) with standardized vertex/edge properties</li> <li>Solver Framework: Template-based with pluggable solution types (regions, strategies, values) using C++20 concepts</li> <li>CLI Tools: Standardized interface for game generation, solver listing, and benchmarking</li> <li>Modular Solvers: Each game type has subdirectories with independent solvers</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start Guide - Get up and running quickly</li> <li>Building the Library - Detailed build instructions</li> <li>File Formats - Supported input/output formats</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Developer Guide - Setup development environment and contribution guidelines</li> </ul>"},{"location":"#supported-game-types","title":"Supported Game Types","text":"<p>Game Graph Gym supports several types of two-player, zero-sum, non-stochastic games out of the box.</p> <ul> <li>Parity Games: Games with parity winning conditions (\"parity\");</li> <li>Mean-Payoff Games: Games with mean-payoff objectives (\"mean_payoff\");</li> <li>B\u00fcchi Games: Games with B\u00fcchi acceptance conditions (\"buechi\");</li> </ul>"},{"location":"#file-formats","title":"File Formats","text":"<p>All game types support import/export via Graphviz DOT format with custom attributes. See the File Formats guide for detailed specifications.</p>"},{"location":"#command-line-tools","title":"Command-Line Tools","text":"<p>The framework includes several command-line utilities:</p> <ul> <li><code>ggg_X_generate</code>: Generate random game instances for type <code>X</code> (parity,mean_payoff, or stochastic_discounted)</li> <li><code>ggg_X_solver_Y</code> Solve a game of type <code>X</code> using algorithm <code>Y</code></li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>See the Developer Guide for information on setting up a development environment and contributing to the project.</p>"},{"location":"api_guide/","title":"API Guide","text":"<p>This guide covers the core APIs for extending Game Graph Gym with new game types and solvers.</p>"},{"location":"api_guide/#adding-new-game-types","title":"Adding New Game Types","text":"<p>Game Graph Gym uses X-macros to automatically generate graph types and utility functions. To add a new game type, you just need to define the vertex, edge, and graph properties and then call the <code>DEFINE_GAME_GRAPH</code> macro as follows.</p> <pre><code>// my_graph.hpp\n#include &lt;libggg/graphs/graph_utilities.hpp&gt;\n\n// Define vertex properties\n#define VERTEX_FIELDS(F) \\\n    F(std::string, name) \\\n    F(int, player) \\\n    F(int, custom_property)\n\n// Define edge properties\n#define EDGE_FIELDS(F) \\\n    F(std::string, label)\n\n// Define graph properties (if any)\n#define GRAPH_FIELDS(F) \\\n    F(std::string, title)\n\n// Generate the complete graph type with utilities\nDEFINE_GAME_GRAPH(VERTEX_FIELDS, EDGE_FIELDS, GRAPH_FIELDS)\n\n// Optionally add utilities specific to your graph type\ninline bool is_valid(const MyGraph &amp;graph) {\n    return true;\n}\n</code></pre> <p>This will generate (in the call-site namespace)</p> <ul> <li><code>Graph</code> - a Boost adjacency_list alias with the declared bundled properties</li> <li><code>Vertex</code>, <code>Edge</code> - descriptor type aliases</li> <li><code>add_vertex()</code> and <code>add_edge()</code> - convenience helpers whose parameter lists     match the declared vertex/edge fields</li> <li><code>parse(std::istream&amp;)</code> and <code>parse(const std::string&amp;)</code> - DOT parsers that     return <code>std::shared_ptr&lt;Graph&gt;</code> on success (or <code>nullptr</code> on failure)</li> <li><code>write(std::ostream&amp;)</code> and <code>write(const std::string&amp;)</code> - DOT writers</li> </ul> <p>To use the generated types and functions:</p> <pre><code>#include \"my_graph.hpp\"\n\n// Create graph and add vertices with named parameters\nGraph graph;\nconst auto v1 = add_vertex(graph, \"vertex1\", 0, 42);\nconst auto v2 = add_vertex(graph, \"vertex2\", 1, 24);\n\n// Add edges with properties\nadd_edge(graph, v1, v2, \"edge_label\");\n\n// Parse from file or stream\nauto graph_ptr = parse(\"input.dot\");\nauto graph_ptr2 = parse(std::cin);\n\n// Write to file or stream\nwrite(*graph_ptr, \"output.dot\");\nwrite(*graph_ptr, std::cout);\n</code></pre>"},{"location":"api_guide/#adding-new-solvers","title":"Adding New Solvers","text":""},{"location":"api_guide/#implementing-a-solver","title":"Implementing a Solver","text":"<p>To implement a new solver, inherit from the unified <code>Solver</code> interface with the appropriate solution type and implement the <code>solve()</code> method. For example, implement a new solver for parity games, that operates on <code>ggg::parity::graph::Graph</code> and produces solutions which encode winning regions only (<code>RSolution&lt;ggg::parity::graph::Graph&gt;</code>) as follows.</p> <pre><code>#include \"libggg/parity/graph.hpp\"\n#include \"libggg/solvers/solver.hpp\"\n\n// Example solver providing winning regions and strategies\nclass YourSolver : public ggg::solvers::Solver&lt;ggg::parity::graph::Graph, ggg::parity::RSolution&gt; {\npublic:\n    ggg::parity::RSolution solve(const ggg::parity::graph::Graph &amp;game) override {\n        ggg::parity::RSolution solution; // Default construct\n\n        const auto [vertices_begin, vertices_end] = boost::vertices(game);\n\n        for (auto it = vertices_begin; it != vertices_end; ++it) {\n            const auto vertex = *it;\n            const auto winner = computeWinner(game, vertex);\n            solution.setWinningPlayer(vertex, winner);\n        }\n\n        return solution;\n    }\n\n    std::string get_name() const override {\n        return \"Your Custom Solver Name\";\n    }\n};\n</code></pre> <p>You can use the project macro to expose this solver as a CLI, following the pattern used by the shipped tools:</p> <pre><code>// inside the game-specific tools/ or main.cpp\nGGG_GAME_SOLVER_MAIN(ggg::parity::graph::Graph, ggg::parity::graph::parse, YourSolver)\n</code></pre> <p>See the implementations of existing solvers under <code>solvers/</code> as examples.</p>"},{"location":"api_guide/#solution-types","title":"Solution Types","text":"<p>We define different solution capabilities via C++ concepts and inheritance. Solution types are named <code>XSolution</code>, where the prefix <code>X</code> indicates what is encoded: initial state only (<code>X=I</code>), winning regions (<code>R</code>), a winning strategy (<code>S</code>), and quantitative (vertex) values (<code>Q</code>). For instance, <code>RSSolution&lt;graphs::ParityGraph&gt;</code>C++ is a type of solution operating on <code>ParityGraph</code>s and which can compute a winning <code>R</code>egion as well as synthesize a <code>S</code>trategy. In more details,</p>"},{"location":"api_guide/#isolutiongraphtype","title":"<code>ISolution&lt;GraphType&gt;</code>","text":"<p>The most basic solution type on <code>&lt;GraphType&gt;</code> graphs. It records only the initial winner label for convenience and provides serialization for solution payloads. There is no solved/valid flag in solutions; solvers either return a result or signal errors via logs/exceptions.</p> <p>See also: <code>include/libggg/solutions/isolution.hpp</code></p>"},{"location":"api_guide/#rsolutiongraphtype","title":"<code>RSolution&lt;GraphType&gt;</code>","text":"<p>Contains info about winning Regions.</p> <p>In addition to the inherited methods of <code>ISolution</code>, solutions of this kind implement:</p> <ul> <li><code>is_won_by_player0(vertex)</code> - Check if vertex is won by player 0</li> <li><code>is_won_by_player1(vertex)</code> - Check if vertex is won by player 1</li> <li><code>get_winning_player(vertex)</code> - Get winning player (0, 1, or -1)</li> <li><code>set_winning_player(vertex, player)</code> - Set winning player for vertex</li> </ul> <p>See also: <code>include/libggg/solutions/rsolution.hpp</code></p>"},{"location":"api_guide/#ssolutiongraphtype","title":"<code>SSolution&lt;GraphType&gt;</code>","text":"<p>Contains info about a winning Strategy</p> <p>In addition to the inherited methods of <code>ISolution</code>, solutions of this kind implement:</p> <ul> <li><code>get_strategy(vertex)</code> - Get strategic choice for vertex</li> <li><code>has_strategy(vertex)</code> - Check if vertex has strategy defined</li> <li><code>set_strategy(vertex, strategy)</code> - Set strategy for vertex</li> </ul> <p>There is actually a second generic parameter specifying the type of strategy contained (mixing, deterministic, positional, finite-memory etc). The default is <code>DeterministicStrategy</code>, representing deterministic and positional strategies (i.e. mappings from vertices to vertices).</p> <p>See also: <code>include/libggg/solutions/ssolution.hpp</code></p>"},{"location":"api_guide/#qsolutiongraphtype-valuetype","title":"<code>QSolution&lt;GraphType, ValueType&gt;</code>","text":"<p>Contains info about Qualitative (vertex) values of type <code>ValueType</code>.</p> <p>In addition to the inherited methods of <code>ISolution</code>, solutions of this kind implement:</p> <ul> <li><code>get_value(vertex)</code> - Get numerical value for vertex</li> <li><code>has_value(vertex)</code> - Check if vertex has value defined</li> <li><code>set_value(vertex, value)</code> - Set value for vertex</li> </ul> <p>See also: <code>include/libggg/solutions/qsolution.hpp</code></p>"},{"location":"api_guide/#combined-solution-types","title":"Combined Solution Types","text":"<ul> <li><code>RSSolution&lt;GraphType&gt;</code>: Regions + Strategies (inherits R and S methods)</li> <li><code>RQSolution&lt;GraphType, ValueType&gt;</code>: Regions + Quantitative values (inherits R and Q methods)</li> <li><code>RSQSolution&lt;GraphType, ValueType&gt;</code>: All capabilities (inherits R, S, and Q methods)</li> </ul> <p>See also: <code>include/libggg/solutions/rssolution.hpp</code>, <code>include/libggg/solutions/rsqsolution.hpp</code></p> <p>Choose the appropriate solution type based on what your solver provides.</p>"},{"location":"building/","title":"Building Game Graph Gym","text":"<p>This page provides detailed instructions for building Game Graph Gym with various configurations. Here, \"libggg\" refers to the library, \"ggg\" is the short name for the project as well as the c++ namespace stuff is defined in.</p>"},{"location":"building/#requirements","title":"Requirements","text":""},{"location":"building/#system-requirements-and-dependencies","title":"System Requirements and Dependencies","text":"<ul> <li>C++20 compatible compiler (GCC 10+, Clang 10+, MSVC 2019+)</li> <li>CMake 3.15 or later</li> <li> <p>Boost Libraries 1.70 or later. Specifically, these components:</p> <ul> <li><code>graph</code> - Required for core graph data structures and algorithms</li> <li><code>program_options</code> - Required for macros related to command-line tools</li> <li><code>filesystem</code> and <code>system</code> - Optional, needed for command-line tools (build options <code>-DBUILD_TESTING=ON</code> or <code>-DTOOLS_ALL=ON</code>)</li> <li><code>unit_test_framework</code> - Optional, needed for unit tests (build option <code>-DBUILD_TESTING=ON</code>)</li> </ul> </li> </ul>"},{"location":"building/#platform-specific-setup","title":"Platform-Specific Setup","text":"<p>Ubuntu/Debian:</p> <pre><code>sudo apt-get update\nsudo apt-get install -y build-essential cmake \\\n    libboost-graph-dev libboost-program-options-dev \\\n    libboost-filesystem-dev libboost-system-dev libboost-test-dev\n</code></pre> <p>Fedora/RHEL:</p> <pre><code>sudo dnf install gcc-c++ cmake \\\n    boost-graph-devel boost-program-options-devel \\\n    boost-filesystem-devel boost-system-devel boost-test-devel\n</code></pre> <p>macOS:</p> <pre><code>brew install cmake boost\n# Note: Homebrew's boost formula includes all components by default\n</code></pre> <p>Windows (vcpkg):</p> <pre><code>vcpkg install boost-graph boost-program-options boost-filesystem boost-system boost-test\n</code></pre>"},{"location":"building/#building-ggg","title":"Building GGG","text":""},{"location":"building/#basic-build","title":"Basic Build","text":"<pre><code>git clone https://github.com/gamegraphgym/ggg.git\ncd ggg\ncmake -S . -B build -DCMAKE_BUILD_TYPE=Release\ncmake --build build\n</code></pre>"},{"location":"building/#build-options","title":"Build Options","text":"<p>Game Graph Gym provides several CMake options to customize the build:</p> Option Default Description <code>TOOLS_ALL</code> OFF Build all tool families (equivalent to enabling all <code>TOOLS_*</code> options below) <code>TOOLS_BUECHI</code> OFF Build executables for buechi game tools (generators, utilities) <code>TOOLS_PARITY</code> OFF Build executables for parity game tools <code>TOOLS_MEAN_PAYOFF</code> OFF Build executables for mean-payoff game tools <code>TOOLS_STOCHASTIC_DISCOUNTED</code> OFF Build executables for discounted stochastic games <code>BUILD_TESTING</code> OFF Build unit tests and enable CTest integration <code>CMAKE_BUILD_TYPE</code> None Build configuration (Debug/Release/RelWithDebInfo/MinSizeRel)"},{"location":"building/#complete-build","title":"Complete Build","text":"<pre><code>cmake -S . -B build \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DTOOLS_ALL=ON \\\n    -DBUILD_TESTING=ON\n\ncmake --build build -j$(nproc)\n</code></pre>"},{"location":"building/#installation","title":"Installation","text":"<p>You can optionally install the library system-wide:</p> <pre><code>cmake --install build\n</code></pre> <p>Or to a custom prefix:</p> <pre><code>cmake --install build --prefix /custom/path\n</code></pre> <p>You can also install specific components (when using the componentized setup):</p> <pre><code># Development headers and CMake package files\ncmake --install build --component dev --prefix /usr\n\n# Shared solver libraries\ncmake --install build --component libs --prefix /usr\n\n# CLI executables (generators and solver CLIs)\ncmake --install build --component bin --prefix /usr\n</code></pre> <p>This will install headers and CMake package files under standard locations:</p> <ul> <li>Headers under <code>${CMAKE_INSTALL_INCLUDEDIR}</code> (e.g., <code>/usr/include/libggg/...</code>)</li> <li>CMake package config under <code>${CMAKE_INSTALL_LIBDIR}/cmake/GameGraphGym</code></li> </ul> <p>The solver libraries (shared) and CLI executables are also installed when those tool families are enabled:</p> <ul> <li>Shared solver libraries under <code>${CMAKE_INSTALL_LIBDIR}</code> (component: <code>libs</code>)</li> <li>Executables under <code>${CMAKE_INSTALL_BINDIR}</code> (component: <code>bin</code>)</li> </ul>"},{"location":"building/#using-game-graph-gym-in-your-project","title":"Using Game Graph Gym in Your Project","text":""},{"location":"building/#cmake-integration","title":"CMake Integration","text":"<p>Add Game Graph Gym to your CMake project:</p> <pre><code>find_package(GameGraphGym REQUIRED)\ntarget_link_libraries(your_target PRIVATE GameGraphGym::ggg)\n</code></pre>"},{"location":"building/#manual-integration","title":"Manual Integration","text":"<p>If building without installation:</p> <pre><code># Find Boost library. Libggg requires graph and program_options components \n# (also add `system`, `filesystem` for tools, and `unit_test_framework` for tests)\nfind_package(Boost REQUIRED COMPONENTS graph program_options)\n\n# Add Game Graph Gym\nadd_subdirectory(path/to/libggg)\ntarget_link_libraries(your_target PRIVATE ggg Boost::graph Boost::program_options)\ntarget_compile_features(your_target PRIVATE cxx_std_20)\n</code></pre>"},{"location":"building/#troubleshooting","title":"Troubleshooting","text":""},{"location":"building/#common-issues","title":"Common Issues","text":"<p>Boost not found:</p> <pre><code>CMAKE_ERROR: Could not find Boost\n</code></pre> <p>Solution: Install Boost development packages or set <code>BOOST_ROOT</code></p> <p>C++20 not supported:</p> <pre><code>error: 'auto' not allowed in non-static class member\n</code></pre> <p>Solution: Use a newer compiler or set <code>CMAKE_CXX_STANDARD=20</code></p> <p>Link errors with Boost:</p> <pre><code>undefined reference to boost::graph\n</code></pre> <p>Solution: Ensure CMake policy is set: <code>cmake_policy(SET CMP0167 NEW)</code></p>"},{"location":"building/#packaging-with-cpack-deb","title":"Packaging with CPack (DEB)","text":"<p>This project supports component-based packaging using CPack. Components:</p> <ul> <li><code>dev</code>: headers and CMake package configuration</li> <li><code>libs</code>: shared solver libraries</li> <li><code>bin</code>: command-line executables (generators and solver CLIs)</li> </ul> <p>Build and create .deb packages (example for Release):</p> <pre><code>cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DTOOLS_ALL=ON\ncmake --build build -j$(nproc)\ncmake --install build --prefix /usr  # optional install step for local testing\ncd build &amp;&amp; cpack -C Release -G DEB\n</code></pre> <p>This produces separate packages like <code>gamegraphgym-dev</code>, <code>gamegraphgym-libs</code>, and <code>gamegraphgym-bin</code>.</p>"},{"location":"building/#performance-builds","title":"Performance Builds","text":"<p>For maximum performance:</p> <pre><code>cmake -S . -B build \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DCMAKE_CXX_FLAGS=\"-O3 -DNDEBUG -march=native\"\n</code></pre>"},{"location":"building/#debug-builds","title":"Debug Builds","text":"<p>For debugging with full symbols:</p> <pre><code>cmake -S . -B build \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DCMAKE_CXX_FLAGS=\"-g -O0\"\n</code></pre>"},{"location":"developing/","title":"Development Guide","text":"<p>This guide covers setting up a development environment and contributing to Game Graph Gym.</p>"},{"location":"developing/#project-structure","title":"Project Structure","text":"<p>The repository is organized as follows:</p> <pre><code>.\n\u251c\u2500\u2500 docs/         # Source files for the documentation (built with MkDocs)\n\u251c\u2500\u2500 cmake/        # CMake configuration modules\n\u251c\u2500\u2500 include/      # Public C++ headers for the library\n\u251c\u2500\u2500 src/          # Implementations\n\u251c\u2500\u2500 tests/        # Unit and integration tests\n\u2514\u2500\u2500 tools/        # CLI tools (e.g., game generators, benchmarks)\n</code></pre>"},{"location":"developing/#development-setup","title":"Development Setup","text":"<p>Set up development build as follows.</p> <pre><code>cmake -S . -B build \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DTOOLS_ALL=ON \\\n    -DBUILD_TESTING=ON\n\ncmake --build build\n</code></pre> <p>Language Server Support</p> <p>To use clangd for C++ language server support, generate a <code>compile_commands.json</code> file:</p> <pre><code>cmake -S . -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON\nln -s build/compile_commands.json .\n</code></pre>"},{"location":"developing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"developing/#use-boost-graph-library-features-where-possible","title":"Use Boost Graph Library features where possible","text":"<p>For example, use iterators provided by Boost Graph functions when iterating over vertices or edges, as follows.</p> <pre><code>// iterate over all vertices\nconst auto [vertices_begin, vertices_end] = boost::vertices(graph);\nfor (const auto&amp; vertex : boost::make_iterator_range(vertices_begin, vertices_end)) {\n    // Process vertex\n}\n</code></pre> <p>Access properties directly:</p> <pre><code>// if graph is a ParityGraph and vertex one of its vertices\nconst auto player = graph[vertex].player;\nconst auto priority = graph[vertex].priority;\n</code></pre>"},{"location":"developing/#code-formatting","title":"Code Formatting","text":"<p>To maintain a consistent code format across the project, format your code using <code>clang-format</code>, according to the style set up in <code>/.clang-format</code>.</p> <ul> <li> <p>In VS Code with the official C/C++ extension, just use Ctrl+Shift+F to reformat;</p> </li> <li> <p>To format all files within the (project) directory, use</p> <pre><code>find . -name '*.hpp' -o -name '*.cpp' | xargs clang-format -i\n</code></pre> </li> <li> <p>Consider setting up a git hook <code>.git/hooks/pre-commit</code> to automatically format code before committing:</p> <pre><code>C_CHANGED_FILES = $(git diff --cached --name-only --diff-filter=ACM | grep -Ee \"\\.[ch]$\")\nCXX_CHANGED_FILES = $(git diff --cached --name-only --diff-filter=ACM | grep -Ee \"\\.([chi](pp|xx)|(cc|hh|ii)|[CHI])$\")\n/usr/bin/clang-format -i -style=file ${CXX_CHANGED_FILES}\n</code></pre> </li> </ul>"},{"location":"developing/#testing","title":"Testing","text":"<p>Tests are disabled by default. To build and run tests, enable them during configuration:</p>"},{"location":"developing/#running-tests","title":"Running Tests","text":"<pre><code># Configure with tests enabled\ncmake -S . -B build -DBUILD_TESTING=ON\ncmake --build build\n\n# Run all tests\ncd build &amp;&amp; ctest --output-on-failure\n\n# Alternative test runner\ncd build &amp;&amp; make test\n\n# Run specific test\nctest -R test_name\n\n# Run with verbose output\nctest --verbose\n</code></pre>"},{"location":"developing/#writing-tests","title":"Writing Tests","text":"<p>Tests use a simple assertion framework. Place test files in <code>tests/</code>:</p> <pre><code>// test/test_new_feature.cpp\n#include \"test_common.hpp\"\n#include &lt;libggg/your_header.hpp&gt;\n\nvoid test_basic_functionality() {\n    // Create test data\n    ParityGame game;\n    const auto vertex = boost::add_vertex({0, \"test\", 0}, game);\n\n    // Test functionality\n    ASSERT_EQ(boost::num_vertices(game), 1);\n    ASSERT_EQ(game[vertex].name, \"test\");\n}\n\nint main() {\n    test_basic_functionality();\n    return 0;\n}\n</code></pre>"},{"location":"developing/#test-coverage","title":"Test Coverage","text":"<ul> <li>Cover normal cases and edge cases</li> <li>Test error conditions and input validation</li> <li>Use descriptive test names explaining what is tested</li> <li>Keep tests independent and deterministic</li> </ul>"},{"location":"developing/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please follow these guidelines:</p>"},{"location":"developing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository and create your feature branch from main</li> <li>Create feature branch from main: <code>git checkout -b feature/new-solver</code></li> <li>Implement changes following code style guidelines</li> <li>Add/update tests for new functionality  </li> <li>Update documentation if needed</li> <li>Ensure all tests pass: <code>ctest --output-on-failure</code></li> <li>Submit pull request with clear description</li> </ol>"},{"location":"developing/#git-workflow","title":"Git Workflow","text":"<pre><code># Fork and clone your fork\ngit clone https://github.com/your-username/ggg.git\ncd ggg\n\n# Create feature branch\ngit checkout -b feature/new-solver\n\n# Make changes and commit\ngit add .\ngit commit -m \"Add new solver implementation\"\n\n# Push and create PR\ngit push origin feature/new-solver\n</code></pre>"},{"location":"developing/#license","title":"License","text":"<p>This project is licensed under the Apache License 2.0 - see the LICENSE file for details.</p>"},{"location":"file_formats/","title":"File Formats","text":"<p>Game Graph Gym supports reading and writing game graphs in Graphviz DOT format with custom attributes for different game types.</p>"},{"location":"file_formats/#common-format-elements","title":"Common Format Elements","text":"<p>All game graph types share these common elements:</p>"},{"location":"file_formats/#vertex-attributes","title":"Vertex Attributes","text":"<ul> <li><code>name</code> (string): Human-readable vertex identifier</li> <li><code>player</code> (int): Owning player (0 or 1)</li> </ul>"},{"location":"file_formats/#edge-attributes","title":"Edge Attributes","text":"<ul> <li><code>label</code> (string): Human-readable edge label</li> </ul>"},{"location":"file_formats/#game-specific-formats","title":"Game-Specific Formats","text":""},{"location":"file_formats/#parity-games","title":"Parity Games","text":"<p>Parity games add the following vertex attribute:</p> <ul> <li><code>priority</code> (int): Priority value for parity condition</li> </ul> <p>Example:</p> <pre><code>digraph ParityGame {\n    v0 [name=\"start\", player=0, priority=2];\n    v1 [name=\"choice\", player=1, priority=1]; \n    v2 [name=\"target\", player=0, priority=0];\n\n    v0 -&gt; v1 [label=\"move\"];\n    v1 -&gt; v2 [label=\"choose\"];\n    v2 -&gt; v0 [label=\"restart\"];\n}\n</code></pre>"},{"location":"file_formats/#mean-payoff-games","title":"Mean-Payoff Games","text":"<p>Mean-payoff games add the following vertex attribute:</p> <ul> <li><code>weight</code> (int): Weight value for mean-payoff calculation</li> </ul> <p>Example:</p> <pre><code>digraph MeanPayoffGame {\n    v0 [name=\"start\", player=0, weight=5];\n    v1 [name=\"middle\", player=1, weight=-2];\n    v2 [name=\"end\", player=0, weight=3];\n\n    v0 -&gt; v1 [label=\"forward\"];\n    v1 -&gt; v2 [label=\"advance\"];\n    v2 -&gt; v0 [label=\"cycle\"];\n}\n</code></pre>"},{"location":"file_formats/#buchi-games","title":"B\u00fcchi Games","text":"<p>B\u00fcchi games use the common format with additional semantic interpretation:</p> <ul> <li>Accepting vertices are typically marked with specific priorities or names</li> <li>The exact acceptance condition depends on the specific variant</li> </ul>"},{"location":"file_formats/#parser-usage","title":"Parser Usage","text":"<p>All parsers follow the same interface pattern, using free functions:</p> <pre><code>#include &lt;libggg/parity/graph.hpp&gt;\n\n// Parse from file\nauto game = ggg::parity::graph::parse(\"game.dot\");\n\n// Parse from stream\n#include &lt;fstream&gt;\nstd::ifstream in(\"game.dot\");\nauto game2 = ggg::parity::graph::parse(in);\n</code></pre>"},{"location":"file_formats/#writing-games","title":"Writing Games","text":"<p>Games can be written back to DOT format using the appropriate writer functions:</p> <pre><code>#include &lt;libggg/parity/graph.hpp&gt;\n\nggg::parity::graph::write(*game, \"output.dot\");\n</code></pre>"},{"location":"file_formats/#validation","title":"Validation","text":"<p>The parsers perform basic validation:</p> <ul> <li>Required attributes must be present</li> <li>Player values must be 0 or 1  </li> <li>Numeric attributes must be valid integers</li> <li>Graph structure must be well-formed</li> </ul> <p>Invalid files will throw parsing exceptions with descriptive error messages.</p>"},{"location":"quick_start/","title":"Quick Start Guide","text":""},{"location":"quick_start/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the required dependencies installed: The following lists packages as in Ubuntu/Debian. For other platforms (macOS, Fedora/RHEL, Windows), see the detailed build instructions.</p> <pre><code>sudo apt-get install -y build-essential cmake \\\n    libboost-graph-dev libboost-program-options-dev \\\n    libboost-filesystem-dev libboost-system-dev libboost-test-dev\n</code></pre>"},{"location":"quick_start/#building-tools-and-solvers","title":"Building Tools and Solvers","text":"<pre><code># Clone the repository\ngit clone https://github.com/gamegraphgym/ggg.git\ncd ggg\n\n# Configure build with all components\ncmake -S . -B build \\\n    -DCMAKE_BUILD_TYPE=Release \\\n    -DTOOLS_ALL=ON\n\n# Build the project\ncmake --build build -j$(nproc)\n</code></pre>"},{"location":"quick_start/#running-your-first-example","title":"Running Your First Example","text":"<p>After building, try running the basic usage example. All binaries are placed in <code>build/bin/</code>.</p> <pre><code># Generate some test games (generator executables live in build/bin)\n# Example: parity generator\n./build/bin/ggg_parity_generate -o test_games -n 5 -v 20\n\n# Run a solver on the generated games (solver CLIs are in build/bin/)\n./build/bin/ggg_parity_solver_recursive test_games/game_0.dot\n\n# As above but with debug log on stderr (and moved to log.txt)\n./build/bin/ggg_parity_solver_recursive test_games/game_0.dot -vv 2&amp;&gt; log.txt\n</code></pre>"},{"location":"quick_start/#using-the-api-in-your-code","title":"Using the API in Your Code","text":"<p>Here's a minimal example of using Game Graph Gym in your own project:</p> <pre><code>#include &lt;libggg/libggg.hpp&gt;\n#include \"libggg/parity/solvers/recursive.hpp\"  // get hold of some solver\n\nint main() {\n    // Load a Parity Graph from DOT file\n    auto game = ggg::graphs::parse_parity_graph_from_file(\"game.dot\");\n\n    // Solve using a solver that provides regions and strategies (RS solution)\n    auto solver = std::make_unique&lt;ggg::parity::RecursiveParitySolver&gt;();\n    auto solution = solver-&gt;solve(game);\n\n    // Inspect results (solved-state flag removed)\n    std::cout &lt;&lt; \"Vertex v0 won by player: \"\n              &lt;&lt; solution.get_winning_player(v0) &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"quick_start/#next-steps","title":"Next Steps","text":"<ul> <li>Read the detailed build instructions</li> </ul>"}]}