# GitHub Copilot Instructions for Game Graph Gym

## Project Architecture Overview

**Game Graph Gym (GGG)** is a C++20 framework for implementing and benchmarking game-theoretic solvers. The architecture consists of:

- **Core Library** (`libggg`): Built on Boost Graph Library, provides graph types (Parity, Mean-Payoff) with standardized vertex/edge properties
- **Solver Framework**: Template-based with pluggable solution types (regions, strategies, values) using C++20 concepts
- **CLI Tools**: Standardized interface for game generation, solver listing, and benchmarking
- **Modular Solvers**: Each game type has subdirectories with independent solvers using `GGG_GAME_SOLVER_MAIN` macro

### Key Design Patterns

1. **Solution Capability System**: Solutions are composed using capabilities (R=regions, S=strategies, Q=quantitative values, I=initial state). Use `RSolution<GraphType>`, `RSSolution<GraphType>`, etc.

2. **Solver Interface**: All solvers inherit from `Solver<GraphType, SolutionType>` and implement `solve()` and `getName()`.

3. **Graph Types**: Use `ParityGraph`/`MPGraph` with bundled properties accessed via `graph[vertex].property`.

4. **Standardized CLI**: All solver binaries use `GGG_GAME_SOLVER_MAIN(GraphType, ParserType, SolverType)` macro for consistent interface.

## Development Workflows

### Building
```bash
# Full build with tools and solvers
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release -DBUILD_ALL_SOLVERS=ON -DBUILD_TOOLS=ON
cmake --build build -j$(nproc)

# Development build with tests
cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DBUILD_TESTING=ON
```

### Testing
```bash
# Enable testing and run
cmake -DBUILD_TESTING=ON ..
make test_ggg && ./test_ggg
```

### Adding a New Solver
1. Create `solvers/gametype/solvername/` directory
2. Implement solver inheriting from `Solver<GraphType, SolutionType>`
3. Create `main.cpp` with `GGG_GAME_SOLVER_MAIN(graphs::ParityGraph, parsers::ParityGraphParser, solvers::YourSolver)`
4. Follow existing CMakeLists.txt patterns

## Code Style Guidelines

This repository uses C++20. Focus on practical, project-specific patterns rather than generic C++ advice.

### Formatting and Linting Enforcement

All C++ code (including code generated by Copilot or Copilot Chat) **must comply** with the formatting and linting rules defined in the project root `.clang-format` and `.clang-tidy` files.

- Do not generate or accept code that violates these rules.
- Always run `clang-format` and `clang-tidy` on new or modified code before submitting or merging changes.
- If using Copilot, always prompt it to follow these rules for any C++ code generation.
- Editors and CI should be configured to enforce these rules automatically.

**Summary:**
> All C++ code must be formatted and linted according to `.clang-format` and `.clang-tidy` in the project root. This applies to all contributors and all Copilot-generated code.

### Project-Specific Guidelines

#### 1. Boost Graph Library Integration
- Use structured bindings: `const auto [vertices_begin, vertices_end] = boost::vertices(graph);`
- Access bundled properties: `graph[vertex].player`
- Use range-based loops with `boost::make_iterator_range`

#### 2. Error Handling
- Use exceptions for error conditions that should not be ignored
- Return `std::optional` for operations that may legitimately fail
- Use `assert` for debug-time checks of preconditions

#### 3. CMake Integration  
In all `CMakeLists.txt` files that use Boost libraries, set this before any `find_package(Boost ...)` call:
```cmake
cmake_policy(SET CMP0167 NEW)
```

#### 4. Testing
- Write tests that cover both normal and edge cases
- Follow the existing test structure and naming conventions
- Ensure all new functionality has corresponding tests

#### 5. Documentation
- Always include Doxygen-style comments for public APIs
- For solver implementations, document time and space complexity in comments
- Include algorithm running time analysis in solver class documentation

#### 6. API Design
- Never create backwards compatibility shims or legacy API support
- The API is work in progress - prefer minimal, clean code over compatibility layers
- When API changes are needed, update calling code directly rather than maintaining old interfaces

#### 7. Code Review Guidelines
- Use GitHub's suggestion syntax for review comments to create clickable fixes
- Format suggestions using triple backticks with "suggestion" language tag
- Provide specific, actionable improvements rather than general advice

## Project-Specific Implementation Patterns

### Game Graph Interactions
```cpp
// Access vertex properties using bundled properties
const auto player = graph[vertex].player;
const auto priority = graph[vertex].priority;

// Iterate over vertices with structured bindings
const auto [vertices_begin, vertices_end] = boost::vertices(graph);
for (const auto& vertex : boost::make_iterator_range(vertices_begin, vertices_end)) {
    // Process vertex
}

// Use utility functions for common operations
auto vertex = addVertex(graph, "vertex_name", player, priority);
bool hasEdge = hasEdgeToVertex(graph, source, target);
```

### Solution Construction Patterns
```cpp
// Use appropriate solution type for solver capabilities
RSSolution<ParityGraph> solution(true); // Regions + Strategies
solution.setWinningPlayer(vertex, 0);
solution.setStrategy(vertex, target_vertex);

// For solvers that only compute regions
RSolution<ParityGraph> solution(true);
solution.setWinningPlayer(vertex, player);
```

### Benchmarking and CLI Integration
- All solver binaries automatically get `--csv`, `--time-only`, `--solver-name` flags
- Place solver binaries in `build/solvers/gametype/solvername/` for auto-discovery
- Use `GGG_GAME_SOLVER_MAIN` macro to ensure CLI compatibility with benchmark tools

### File Format Conventions
- Game graphs use DOT format with custom properties: `name`, `player` (vertices); `priority` (parity); `weight` (mean-payoff)
- Input/output via stdin/stdout by default for pipeline compatibility
- CSV output format for benchmarking integration
